<!DOCTYPE HTML><html><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<title>40-配置多数据源经历</title>
    
<style id="wiz_custom_css">html, .wiz-editor-body {font-size: 12pt;}.wiz-editor-body {font-family: Helvetica, 'Hiragino Sans GB', '寰蒋闆呴粦', 'Microsoft YaHei UI', SimSun, SimHei, arial, sans-serif;line-height: 1.7;margin: 0 auto;padding: 20px 16px;padding: 1.25rem 1rem;}.wiz-editor-body h1,.wiz-editor-body h2,.wiz-editor-body h3,.wiz-editor-body h4,.wiz-editor-body h5,.wiz-editor-body h6 {margin:20px 0 10px;margin:1.25rem 0 0.625rem;padding: 0;font-weight: bold;}.wiz-editor-body h1 {font-size:20pt;font-size:1.67rem;}.wiz-editor-body h2 {font-size:18pt;font-size:1.5rem;}.wiz-editor-body h3 {font-size:15pt;font-size:1.25rem;}.wiz-editor-body h4 {font-size:14pt;font-size:1.17rem;}.wiz-editor-body h5 {font-size:12pt;font-size:1rem;}.wiz-editor-body h6 {font-size:12pt;font-size:1rem;color: #777777;margin: 1rem 0;}.wiz-editor-body div,.wiz-editor-body p,.wiz-editor-body ul,.wiz-editor-body ol,.wiz-editor-body dl,.wiz-editor-body li {margin:8px 0;}.wiz-editor-body blockquote,.wiz-editor-body table,.wiz-editor-body pre,.wiz-editor-body code {margin:8px 0;}.wiz-editor-body .CodeMirror pre {margin:0;}.wiz-editor-body ul,.wiz-editor-body ol {padding-left:32px;padding-left:2rem;}.wiz-editor-body ol.wiz-list-level1 > li {list-style-type:decimal;}.wiz-editor-body ol.wiz-list-level2 > li {list-style-type:lower-latin;}.wiz-editor-body ol.wiz-list-level3 > li {list-style-type:lower-roman;}.wiz-editor-body blockquote {padding: 0 12px;}.wiz-editor-body blockquote > :first-child {margin-top:0;}.wiz-editor-body blockquote > :last-child {margin-bottom:0;}.wiz-editor-body img {border:0;max-width:100%;height:auto !important;margin:2px 0;}.wiz-editor-body table {border-collapse:collapse;border:1px solid #bbbbbb;}.wiz-editor-body td,.wiz-editor-body th {padding:4px 8px;border-collapse:collapse;border:1px solid #bbbbbb;min-height:28px;word-break:break-word;box-sizing: border-box;}.wiz-hide {display:none !important;}</style></head>

<body class="wiz-editor-body"  spellcheck="false"><div></div><h1 class="md-end-block md-heading md-focus" style="font-size:2.25rem;color:rgb(51, 51, 51);"><span class="md-expand"><a href="https://www.cnblogs.com/puyangsky/p/6133553.html" style="color:rgb(65, 131, 196);"><span>【Java】一次SpringMVC+ Mybatis 配置多数据源经历</span></a></span></h1><h2 class="md-end-block md-heading" style="font-size:1.75rem;color:rgb(51, 51, 51);"><span>需求</span></h2><p style="color:rgb(51, 51, 51);font-size:1rem;"><span class="md-line md-end-block"><span>现在在维护的是学校的一款信息服务APP的后台，最近要开发一些新功能，其中一个就是加入学校电影院的在线购票。在线购票实际上已经有一套系统了，但是是外包给别人开发的，我们拿不到代码只能拿到数据库，并且也不一定能很好的兼容之前的代码，所以需要基于这个数据库来进行新的开发。</span></span></p><p style="color:rgb(51, 51, 51);font-size:1rem;"><span class="md-line md-end-block"><span>现在用的后台是SpringMVC+Mybatis+MySQL开发的，购票用的是SQL Server 2008（好古老的东西了），因为要用一套用户体系所以不可能再去单独为了这个功能弄一个系统出来，因此要在原项目中兼容这个数据库。</span></span></p><h2 class="md-end-block md-heading" style="font-size:1.75rem;color:rgb(51, 51, 51);"><span>问题</span></h2><p style="color:rgb(51, 51, 51);font-size:1rem;"><span class="md-line md-end-block"><span>如何在一个web项目中使用两个数据源，并且不同的接口可以按需选择数据库。</span></span></p><h2 class="md-end-block md-heading" style="font-size:1.75rem;color:rgb(51, 51, 51);"><span>方案</span></h2><h3 class="md-end-block md-heading" style="font-size:1.5rem;color:rgb(51, 51, 51);"><span>最开始的做法</span></h3><p style="color:rgb(51, 51, 51);font-size:1rem;"><span class="md-line md-end-block"><span>因为我们的项目用的是Mybatis作为ORM框架，在其配置文件中可以配置数据源信息，原始配置如下：</span></span></p><p style="color:rgb(51, 51, 51);font-size:1rem;"><span class="md-line md-end-block"><span>spring-mybatis.xml</span></span></p><pre class="md-fences md-end-block md-fences-with-lineno contain-cm modeLoaded" style="font-size:0.9rem;background-color:rgb(248, 248, 248);color:rgb(51, 51, 51);">  <span>&lt;!-- 引入配置文件 --&gt;</span><br>  <span>&lt;bean id="propertyConfigurer"</span><br>  <span> &nbsp;  class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt;</span><br>  <span> &nbsp;  &lt;property name="location" value="classpath:jdbc.properties" /&gt;</span><br>  <span>&lt;/bean&gt;</span><br>  <span>&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"&gt;</span><br>  <span> &nbsp;  &lt;property name="driverClassName" value="${jdbc.driver}" /&gt;</span><br>  <span> &nbsp;  &lt;property name="url" value="${jdbc.url}" /&gt;</span><br>  <span> &nbsp;  &lt;property name="username" value="${jdbc.username}" /&gt;</span><br>  <span> &nbsp;  &lt;property name="password" value="${jdbc.password}" /&gt;</span><br>  <span> &nbsp;  &lt;!-- 初始化连接大小 --&gt;</span><br>  <span> &nbsp;  &lt;property name="initialSize" value="${jdbc.initialSize}"&gt;&lt;/property&gt;</span><br>  <span> &nbsp;  &lt;!-- 连接池最大数量 --&gt;</span><br>  <span> &nbsp;  &lt;property name="maxActive" value="${jdbc.maxActive}"&gt;&lt;/property&gt;</span><br>  <span> &nbsp;  &lt;!-- 连接池最大空闲 --&gt;</span><br>  <span> &nbsp;  &lt;property name="maxIdle" value="${jdbc.maxIdle}"&gt;&lt;/property&gt;</span><br>  <span> &nbsp;  &lt;!-- 连接池最小空闲 --&gt;</span><br>  <span> &nbsp;  &lt;property name="minIdle" value="${jdbc.minIdle}"&gt;&lt;/property&gt;</span><br>  <span> &nbsp;  &lt;!-- 获取连接最大等待时间 --&gt;</span><br>  <span> &nbsp;  &lt;property name="maxWait" value="${jdbc.maxWait}"&gt;&lt;/property&gt;</span><br>  <span>&lt;/bean&gt;</span><br>  <span><span></span></span><br>  <span>&lt;!-- spring和MyBatis完美整合，不需要mybatis的配置映射文件 --&gt;</span><br>  <span>&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt;</span><br>  <span> &nbsp;  &lt;property name="dataSource" ref="dataSource" /&gt;</span><br>  <span> &nbsp;  &lt;!-- 自动扫描mapping.xml文件 --&gt;</span><br>  <span> &nbsp;  &lt;property name="mapperLocations" value="classpath:path/to/mapping/*.xml"&gt;&lt;/property&gt;</span><br>  <span>&lt;/bean&gt;</span><br>  <span><span></span></span><br>  <span>&lt;!-- DAO接口所在包名，Spring会自动查找其下的类 --&gt;</span><br>  <span>&lt;bean id="mapperScannerConfigurer" class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt;</span><br>  <span> &nbsp;  &lt;property name="basePackage" value="path.to.dao" /&gt;</span><br>  <span> &nbsp;  &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"&gt;&lt;/property&gt;</span><br>  <span>&lt;/bean&gt;</span><br>  <span><span></span></span><br>  <span>&lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt;</span><br>  <span>&lt;bean id="transactionManager"</span><br>  <span> &nbsp;  class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;</span><br>  <span> &nbsp;  &lt;property name="dataSource" ref="dataSource" /&gt;</span><br>  <span>&lt;/bean&gt;</span></pre><p style="color:rgb(51, 51, 51);font-size:1rem;"><span class="md-line md-end-block"><span>然后我就天真的认为是不是再新建一个dataSource的bean、sqlSessionFactory、mapperScannerConfigurer和transactionManager，把数据库连接信息改一下，就可以同时使用两个数据库了。但是尝试之后发现第二个数据库的mapping文件根本没有被初始化进spring的context中，报了Invalid bound statement (not found)这个错，查了一下说是配置文件不对等原因造成的。后来发现实际上因为上面的配置文件中的sqlSessionFactory在spring中是单例的，因此按照我的想法第二个sqlSessionFactory根本就不会被实例化。所以此方法行不通！</span></span></p><h3 class="md-end-block md-heading" style="font-size:1.5rem;color:rgb(51, 51, 51);"><span>改进做法</span></h3><p style="color:rgb(51, 51, 51);font-size:1rem;"><span class="md-line md-end-block"><span>最后是在</span><span><a href="http://blog.csdn.net/alaahong/article/details/8707915" style="color:rgb(65, 131, 196);"><span>这篇博客</span></a></span><span>中找到了正确可行的解决方法：使用Spring提供的AbstractRoutingDataSource类来根据请求路由到不同的数据源。具体做法是</span></span><span class="md-line md-end-block"><span>先设置两个不同的dataSource代表不同的数据源，再建一个总的dynamicDataSource，根据不同的请求去设置dynamicDataSource。代码如下：</span></span></p><p style="color:rgb(51, 51, 51);font-size:1rem;"><span class="md-line md-end-block"><span>配置文件spring-mybatis.xml</span></span></p><pre class="md-fences md-end-block md-fences-with-lineno contain-cm modeLoaded" style="font-size:0.9rem;background-color:rgb(248, 248, 248);color:rgb(51, 51, 51);">  <span>&lt;!--统一的dataSource--&gt;</span><br>  <span>&lt;bean id="dynamicDataSource" class="path.to.DynamicDataSource" &gt;</span><br>  <span> &nbsp;  &lt;property name="targetDataSources"&gt;</span><br>  <span> &nbsp; &nbsp; &nbsp;  &lt;map key-type="java.lang.String"&gt;</span><br>  <span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &lt;!--通过不同的key决定用哪个dataSource--&gt;</span><br>  <span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &lt;entry value-ref="dataSource" key="dataSource"&gt;&lt;/entry&gt;</span><br>  <span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &lt;entry value-ref="mssqlDataSource" key="mssqlDataSource"&gt;&lt;/entry&gt;</span><br>  <span> &nbsp; &nbsp; &nbsp;  &lt;/map&gt;</span><br>  <span> &nbsp;  &lt;/property&gt;</span><br>  <span> &nbsp;  &lt;!--设置默认的dataSource--&gt;</span><br>  <span> &nbsp;  &lt;property name="defaultTargetDataSource" ref="dataSource"&gt;</span><br>  <span> &nbsp;  &lt;/property&gt;</span><br>  <span>&lt;/bean&gt;</span><br>  <span><span></span></span><br>  <span>&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"&gt;</span><br>  <span> &nbsp;  &lt;property name="driverClassName" value="${jdbc.driver}" /&gt;</span><br>  <span> &nbsp;  &lt;property name="url" value="${jdbc.url}" /&gt;</span><br>  <span> &nbsp;  &lt;property name="username" value="${jdbc.username}" /&gt;</span><br>  <span> &nbsp;  &lt;property name="password" value="${jdbc.password}" /&gt;</span><br>  <span> &nbsp;  &lt;!-- 初始化连接大小 --&gt;</span><br>  <span> &nbsp;  &lt;property name="initialSize" value="${jdbc.initialSize}"&gt;&lt;/property&gt;</span><br>  <span> &nbsp;  &lt;!-- 连接池最大数量 --&gt;</span><br>  <span> &nbsp;  &lt;property name="maxActive" value="${jdbc.maxActive}"&gt;&lt;/property&gt;</span><br>  <span> &nbsp;  &lt;!-- 连接池最大空闲 --&gt;</span><br>  <span> &nbsp;  &lt;property name="maxIdle" value="${jdbc.maxIdle}"&gt;&lt;/property&gt;</span><br>  <span> &nbsp;  &lt;!-- 连接池最小空闲 --&gt;</span><br>  <span> &nbsp;  &lt;property name="minIdle" value="${jdbc.minIdle}"&gt;&lt;/property&gt;</span><br>  <span> &nbsp;  &lt;!-- 获取连接最大等待时间 --&gt;</span><br>  <span> &nbsp;  &lt;property name="maxWait" value="${jdbc.maxWait}"&gt;&lt;/property&gt;</span><br>  <span>&lt;/bean&gt;</span><br>  <span><span></span></span><br>  <span>&lt;!--电影票数据库是mssql2008，单独的数据库，配置如下--&gt;</span><br>  <span>&lt;bean id="mssqlDataSource" class="org.apache.commons.dbcp.BasicDataSource"&gt;</span><br>  <span> &nbsp;  &lt;property name="driverClassName" value="${jdbc-mssql.driver}" /&gt;</span><br>  <span> &nbsp;  &lt;property name="url" value="${jdbc-mssql.url}" /&gt;</span><br>  <span> &nbsp;  &lt;property name="username" value="${jdbc-mssql.username}" /&gt;</span><br>  <span> &nbsp;  &lt;property name="password" value="${jdbc-mssql.password}" /&gt;</span><br>  <span> &nbsp;  &lt;!-- 初始化连接大小 --&gt;</span><br>  <span> &nbsp;  &lt;property name="initialSize" value="${jdbc.initialSize}"&gt;&lt;/property&gt;</span><br>  <span> &nbsp;  &lt;!-- 连接池最大数量 --&gt;</span><br>  <span> &nbsp;  &lt;property name="maxActive" value="${jdbc.maxActive}"&gt;&lt;/property&gt;</span><br>  <span> &nbsp;  &lt;!-- 连接池最大空闲 --&gt;</span><br>  <span> &nbsp;  &lt;property name="maxIdle" value="${jdbc.maxIdle}"&gt;&lt;/property&gt;</span><br>  <span> &nbsp;  &lt;!-- 连接池最小空闲 --&gt;</span><br>  <span> &nbsp;  &lt;property name="minIdle" value="${jdbc.minIdle}"&gt;&lt;/property&gt;</span><br>  <span> &nbsp;  &lt;!-- 获取连接最大等待时间 --&gt;</span><br>  <span> &nbsp;  &lt;property name="maxWait" value="${jdbc.maxWait}"&gt;&lt;/property&gt;</span><br>  <span>&lt;/bean&gt;</span><br>  <span><span></span></span><br>  <span>&lt;!-- spring和MyBatis完美整合，不需要mybatis的配置映射文件 --&gt;</span><br>  <span>&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt;</span><br>  <span> &nbsp;  &lt;property name="dataSource" ref="dynamicDataSource" /&gt;</span><br>  <span> &nbsp;  &lt;!-- 自动扫描mapping.xml文件 --&gt;</span><br>  <span> &nbsp;  &lt;property name="mapperLocations" value="classpath:path/to/mapping/*.xml"&gt;&lt;/property&gt;</span><br>  <span>&lt;/bean&gt;</span><br>  <span><span></span></span><br>  <span>&lt;!-- DAO接口所在包名，Spring会自动查找其下的类 --&gt;</span><br>  <span>&lt;bean id="mapperScannerConfigurer" class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt;</span><br>  <span> &nbsp;  &lt;property name="basePackage" value="path.to.dao" /&gt;</span><br>  <span> &nbsp;  &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"&gt;&lt;/property&gt;</span><br>  <span>&lt;/bean&gt;</span><br>  <span><span></span></span><br>  <span>&lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt;</span><br>  <span>&lt;bean id="transactionManager"</span><br>  <span> &nbsp;  class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;</span><br>  <span> &nbsp;  &lt;property name="dataSource" ref="dynamicDataSource" /&gt;</span><br>  <span>&lt;/bean&gt;</span></pre><p style="color:rgb(51, 51, 51);font-size:1rem;"><span class="md-line md-end-block"><span>DynamicDataSource.java</span></span></p><pre class="md-fences md-end-block md-fences-with-lineno contain-cm modeLoaded" style="font-size:0.9rem;background-color:rgb(248, 248, 248);color:rgb(51, 51, 51);">  <span>public class DynamicDataSource extends AbstractRoutingDataSource {</span><br>  <span> &nbsp;  @Override</span><br>  <span> &nbsp;  protected Object determineCurrentLookupKey() {</span><br>  <span> &nbsp; &nbsp; &nbsp;  return CustomerContextHolder.getCustomerType();</span><br>  <span> &nbsp;  }</span><br>  <span>}</span></pre><p style="color:rgb(51, 51, 51);font-size:1rem;"><span class="md-line md-end-block"><span>CustomerContextHolder.java</span></span></p><pre class="md-fences md-end-block md-fences-with-lineno contain-cm modeLoaded" style="font-size:0.9rem;background-color:rgb(248, 248, 248);color:rgb(51, 51, 51);">  <span>public class CustomerContextHolder {</span><br>  <span> &nbsp;  public static final String DATA_SOURCE_MYSQL = "dataSource";</span><br>  <span> &nbsp;  public static final String DATA_SOURCE_MSSQL = "mssqlDataSource";</span><br>  <span> &nbsp;  //用ThreadLocal来设置当前线程使用哪个dataSource</span><br>  <span> &nbsp;  private static final ThreadLocal&lt;String&gt; contextHolder = new ThreadLocal&lt;String&gt;();</span><br>  <span> &nbsp;  public static void setCustomerType(String customerType) {</span><br>  <span> &nbsp; &nbsp; &nbsp;  contextHolder.set(customerType);</span><br>  <span> &nbsp;  }</span><br>  <span> &nbsp;  public static String getCustomerType() {</span><br>  <span> &nbsp; &nbsp; &nbsp;  String dataSource = contextHolder.get();</span><br>  <span> &nbsp; &nbsp; &nbsp;  if (StringUtils.isEmpty(dataSource)) {</span><br>  <span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  return DATA_SOURCE_MYSQL;</span><br>  <span> &nbsp; &nbsp; &nbsp;  }else {</span><br>  <span> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  return dataSource;</span><br>  <span> &nbsp; &nbsp; &nbsp;  }</span><br>  <span> &nbsp;  }</span><br>  <span> &nbsp;  public static void clearCustomerType() {</span><br>  <span> &nbsp; &nbsp; &nbsp;  contextHolder.remove();</span><br>  <span> &nbsp;  }</span><br>  <span>}</span></pre><p style="color:rgb(51, 51, 51);font-size:1rem;"><span class="md-line md-end-block"><span>ServiceImpl.java</span></span></p><pre class="md-fences md-end-block md-fences-with-lineno contain-cm modeLoaded" style="font-size:0.9rem;background-color:rgb(248, 248, 248);color:rgb(51, 51, 51);">  <span>CustomerContextHolder.setCustomerType(CustomerContextHolder.DATA_SOURCE_MSSQL);</span></pre><p style="color:rgb(51, 51, 51);font-size:1rem;"><span class="md-line md-end-block"><span>值得注意的是在CustomerContextHolder.java中使用了ThreadLocal类的set方法来设置当前线程要选择的dataSource，看一下set方法的源码：</span></span></p><p style="color:rgb(51, 51, 51);font-size:1rem;"><span class="md-line md-end-block"><span>ThreadLocal.set()</span></span></p><pre class="md-fences md-end-block md-fences-with-lineno contain-cm modeLoaded" style="font-size:0.9rem;background-color:rgb(248, 248, 248);color:rgb(51, 51, 51);">  <span>public void set(T value) {</span><br>  <span> &nbsp;  Thread t = Thread.currentThread();</span><br>  <span> &nbsp;  ThreadLocalMap map = getMap(t);</span><br>  <span> &nbsp;  if (map != null)</span><br>  <span> &nbsp; &nbsp; &nbsp;  map.set(this, value);</span><br>  <span> &nbsp;  else</span><br>  <span> &nbsp; &nbsp; &nbsp;  createMap(t, value);</span><br>  <span>}</span></pre><p style="color:rgb(51, 51, 51);font-size:1rem;"><span class="md-line md-end-block"><span>显而易见，获取当前线程，并且使用一个hashmap把需要存储的值设置进去。因为tomcat是用的线程池来处理每个请求，所以用ThreadLocal可以保证线程安全问题。同时这个AbstractRoutingDataSource类也值得好好研究一下。</span></span></p><h2 class="md-end-block md-heading" style="font-size:1.75rem;color:rgb(51, 51, 51);"><span>总结</span></h2><p style="color:rgb(51, 51, 51);font-size:1rem;"><span class="md-line md-end-block"><span>其实这个方案不仅仅可以用来处理不同数据源的问题，同时业务量上来之后需要把数据库进行主从分离或是把一个库分为多个库，都需要用到这样的做法。这次暴露的问题确实也了解了不少，继续学习吧！</span></span></p></body></html>